/* как представить черно белое изображение

int[,] pic = new int [23, 25];

0 - закрашенный пиксель
1 - незакрашенный пиксель

алгоритм:
в первую очередь определяем какую то внутреннею точку, которая находится 
внутри замкнутого контура, после этого нам нужно определить каким образом
будем делать обход по внутреннему контуру, если точка не является закрашенной
ее закрашиваем.
далее определяем правило обхода (идем вверх -потом влево - вниз -вправо)

если мы находимся в текущей точка координаты которой [x, y]

----------------------------
|x-1,y-1 | x-1, y |x-1,y+1 | ходим: вверх-влево-вниз-вправо
----------------------------
| x, y-1 |   x,y  | x, y+1 |
----------------------------
|x+1,y-1 | x+1, y |x+1,y+1 |
----------------------------
*/
int[,] pic = new int[,] //если есть фиксированные данные количесво строк и столбцов указывать необязательно
{
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
{0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};

void PrintImage(int[,] image) 
{
    for (int i = 0; i < image.GetLength(0); i++)  
    {
        for (int j = 0; j <  image.GetLength(1); j++) 
        {
            //Console.Writeline($"{image[i, j]}"); // вместо вывода напишем проверку текущего элемента
            if (image[i, j] == 0) Console.Write($" ");// если текущий элемент = 0, то печатаем пробел
            else Console.Write($"+"); // если = 1, то печаем +
        }
        Console.WriteLine();
    }
}
// теперь напишем метод который будет закрашивать нашу картинку 

void FullImage(int row, int col) //в качестве аргумента указываем позицию строки и столбца с которого начинаем нашу закраску
{
    if (pic[row, col] == 0) // дальше проверяем условие - если наша позиция = 0, т.е он не закрашен, то мы его красим
    {
        pic[row, col] = 1; //закрашиваем
        FullImage(row-1, col); //наверх. далее в методе мы вызываем сам метод и устанавливаем правило, как мы будем двигаться
        FullImage(row, col-1); //влево
        FullImage(row+1, col); //вниз
        FullImage(row, col+1); //вправо
    }
}

PrintImage(pic);
FullImage(13, 13); // в качесвте случайной точки указали (13, 13), т.е. она должна лежать внутри рисунка
PrintImage(pic);

/* когда функция вызывает сама себя - рекурентное оношение
в программировании - рекурсия. */
